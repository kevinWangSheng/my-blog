---
title: "grpc"
date: 2025-11-07
draft: false
tags: ['grpc']
---

# grpc 

## rust ä¸­çš„ grpc

çŸ¥ååº¦æ¯”è¾ƒé«˜çš„å°±æ˜¯ tonic(å®Œæ•´æ­£å¼ç‰ˆè¿˜æ²¡æœ‰å‘å¸ƒ,çœ‹ç›¸å…³å¼€å‘äººè¯´ 26 å¹´å‘å¸ƒç¬¬ä¸€ç‰ˆ)

github: https://github.com/hyperium/tonic

æ–‡æ¡£:https://docs.rs/tonic/latest/tonic/

### åŸºç¡€ä½¿ç”¨

ä¸é…åˆä»»ä½•æ¡†æ¶,å•çº¯ä½¿ç”¨

æ€»ç»“: æµç¨‹æœ‰ç‚¹ç¹ç

1. éœ€è¦æ·»åŠ åŸºç¡€çš„ä¾èµ–(è°ƒç”¨ä¾èµ– tonic, ç”Ÿæˆä»£ç ä¾èµ– tonic_prots_build, åè®®ä¾èµ–: prost)
å¯¹åº”çš„ toml ä¾èµ–

```rust
[[bin]]
name = "server"
path = "src/server.rs"

[[bin]]
name = "client"    # æ”¹åˆ«åæˆä¸ºclient ,ç›´æ¥cargo run --bin client å°±å¯ä»¥è¿è¡Œ(ä¸‹é¢åŒæ ·çš„)
path = "src/client.rs"

[dependencies]
prost = "0.14.1"
tokio = { version = "1.48.0", features = ["macros", "rt-multi-thread", "sync", "time"] }
tokio-stream = "0.1"
tonic = "0.14.2"
tonic-prost = "0.14.2"
[build-dependencies]  # ç¼–è¯‘çš„æ—¶å€™ä½¿ç”¨åˆ°çš„ (cargo build)
tonic-prost-build = "0.14.2"
prost-build = "0.14.1"
tonic-prost = "0.14.2"
```

1. éœ€è¦ç¼–å†™å¯¹åº”çš„ proto 
å¯ä»¥å‚è€ƒ: https://protobuf.dev/programming-guides/proto3/

ä¸¾ä¾‹:

```protobuf
syntax = "proto3";

package test;

message TestRequest {
    string name = 1;
}

message TestResponse {
    string message = 1;
}

service Test {
    rpc sayHello(TestRequest) returns (TestResponse);
    
    rpc sayGoodbye(TestRequest) returns (TestResponse);
}
```

ç„¶åè¿›è¡Œé“¾æ¥,éœ€è¦ç¼–å†™å¯¹åº”çš„ build.rs(ç¼–è¯‘æ—¶ä¼šç”Ÿæˆå¯¹åº”çš„ä»£ç ,é€šè¿‡ tonic-prost-build ç”Ÿæˆå¯¹åº”çš„ rs ä»£ç ), è¿™ä¸ªæ–‡ä»¶å¿…é¡»è¦æ”¾åˆ°è·Ÿä½ å¯¹åº”çš„ cargo è¿è¡Œçš„ç›®å½•åŒçº§(å³ Cargo.toml åŒçº§),è¿™é‡Œå°±æ˜¯æ ¹ç›®å½•

é“¾æ¥çš„å†…å®¹

```protobuf
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_prost_build::configure()
        .out_dir("src/generate") // ç”Ÿæˆæ–‡ä»¶è¾“å‡ºçš„ç›®å½•,å¦‚æœä¸æŒ‡å®š,ä»–ä¼šé»˜è®¤ç”Ÿæˆåœ¨å¯¹åº”çš„ target ç›®å½•ä¸‹çš„å¯¹åº”è·¯å¾„,åé¢ä½ éœ€è¦é€šè¿‡ tonic::include_proto!()å®è¿›è¡Œå¼•å…¥
        .compile_protos(&["proto/hello.proto", "proto/test.proto"], &["proto/"])?;  // è¿™é‡Œæ˜¯ä½ å†™çš„å¯¹åº”çš„ proto æ–‡ä»¶å†…å®¹
    Ok(())
}

```

å¯¹åº”ä½ è¿è¡Œ cargo build ä¹‹åä¼šç”Ÿæˆå¯¹åº”çš„å†…å®¹:

```rust
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TestResponse {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod test_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TestClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TestClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TestClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TestClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TestClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn say_hello(
            &mut self,
            request: impl tonic::IntoRequest<super::TestRequest>,
        ) -> std::result::Result<tonic::Response<super::TestResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/test.Test/sayHello");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("test.Test", "sayHello"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn say_goodbye(
            &mut self,
            request: impl tonic::IntoRequest<super::TestRequest>,
        ) -> std::result::Result<tonic::Response<super::TestResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/test.Test/sayGoodbye");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("test.Test", "sayGoodbye"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod test_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TestServer.
    #[async_trait]
    pub trait Test: std::marker::Send + std::marker::Sync + 'static {
        async fn say_hello(
            &self,
            request: tonic::Request<super::TestRequest>,
        ) -> std::result::Result<tonic::Response<super::TestResponse>, tonic::Status>;
        async fn say_goodbye(
            &self,
            request: tonic::Request<super::TestRequest>,
        ) -> std::result::Result<tonic::Response<super::TestResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct TestServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TestServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TestServer<T>
    where
        T: Test,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/test.Test/sayHello" => {
                    #[allow(non_camel_case_types)]
                    struct sayHelloSvc<T: Test>(pub Arc<T>);
                    impl<T: Test> tonic::server::UnaryService<super::TestRequest>
                    for sayHelloSvc<T> {
                        type Response = super::TestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Test>::say_hello(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = sayHelloSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/test.Test/sayGoodbye" => {
                    #[allow(non_camel_case_types)]
                    struct sayGoodbyeSvc<T: Test>(pub Arc<T>);
                    impl<T: Test> tonic::server::UnaryService<super::TestRequest>
                    for sayGoodbyeSvc<T> {
                        type Response = super::TestResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TestRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Test>::say_goodbye(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = sayGoodbyeSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TestServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "test.Test";
    impl<T> tonic::server::NamedService for TestServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}

```

1. å®Œæˆå¯¹åº”çš„ç»‘å®š:
server :

```rust
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status, transport::Server};

use crate::{hello::{HelloRequest, HelloResponse, greeter_server::{Greeter, GreeterServer}}, test::test_server::{Test, TestServer}};
use crate::test::{TestRequest, TestResponse};

mod hello{
    tonic::include_proto!("hello");
}

mod test{
    include!("generate/test.rs");
}

#[derive(Debug,Default)]
pub struct MyGreeter {
   
}

#[derive(Debug,Default)]
pub struct MyTest {
    
}

#[tonic::async_trait]
impl Test for MyTest {

    async fn say_hello(&self, request: Request<TestRequest>) -> Result<Response<TestResponse>, Status> {
        println!("the request is :{:?}",request);
        
        let response = TestResponse {
            message: r#"hello world this is the response"#.to_string()
        };
        
        Ok(Response::new(response))
    }

    async fn say_goodbye(&self, request: Request<TestRequest>) -> Result<Response<TestResponse>, Status> {
        println!("goodbye, the request is :{:?}",request.into_inner().name);
        
        let response = TestResponse {
            message: r#"goodbye world this is the response"#.to_string()
        };
        
        Ok(Response::new(response))
    }
}

#[tonic::async_trait]
impl Greeter for MyGreeter {
    async fn say_hello(&self,request :Request<HelloRequest>)->Result<Response<HelloResponse>, tonic::Status>{
        println!("Got request :{:?}",request);
        let response = HelloResponse {
            message : format!( "Hello, World, this is from the grpc server ğŸ¦€:{}",request.into_inner().name)
        };
        Ok(Response::new(response))
    }

    type SayHelloStreamStream = ReceiverStream<Result<HelloResponse,Status>>;
    
    async fn say_hello_stream(&self, request: Request<HelloRequest>) -> Result<Response<Self::SayHelloStreamStream>, Status> {
        println!("Got request :{:?}",request);
        let (tx,rx) = tokio::sync::mpsc::channel(5);
        
        tokio::spawn(async move {
            for i in 0..5 {
                let response = HelloResponse{
                    message: format!("this is from the grpc server message :{}",i)
                };
                if tx.send(Ok(response)).await.is_err(){
                    println!("Error sending message");
                }
                // sleep for 1 second
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            }
        });
        print!("Sending message end");
        
        Ok(Response::new(ReceiverStream::new(rx)))
    }
}

#[tokio::main]
async fn main() -> Result<(),Box<dyn std::error::Error>> {
    let addr = "[::]:50051".parse()?;
    
    // start a server 
    let server = MyGreeter::default();
    let test = MyTest::default();
    Server::builder().add_service(GreeterServer::new(server)).add_service(TestServer::new(test)).serve(addr).await?; // è¿›è¡Œå¯¹åº”çš„ rpc çš„ç»‘å®š
    Ok(())
}
```

client:

```rust
use hello::greeter_client::GreeterClient;
use hello::HelloRequest;

use crate::test::TestRequest;
use crate::test::test_client::TestClient;

pub mod hello {
    tonic::include_proto!("hello");
}

pub mod test {
    include!("generate/test.rs");
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // è¿æ¥åˆ°æœåŠ¡å™¨
    let mut client = GreeterClient::connect("http://127.0.0.1:50051").await?;
    
    println!("ğŸ”Œ å·²è¿æ¥åˆ° gRPC æœåŠ¡å™¨\n");
    
    // ===== æµ‹è¯• 1: ä¸€å…ƒ RPC =====
    println!("ğŸ“¤ æµ‹è¯•ä¸€å…ƒ RPC:");
    let request = tonic::Request::new(HelloRequest {
        name: "Shawn".into(),
    });
    
    let test_request = tonic::Request::new(TestRequest{
        name: "Shawn test".into()
    });
    
    let mut test_client = TestClient::connect("http://127.0.0.1:50051").await?;
    let response = client.say_hello(request).await?;
    
    test_client.say_hello(test_request).await?;
    println!("âœ… æ”¶åˆ°å“åº”: {}\n", response.into_inner().message);
    
    
    // ===== æµ‹è¯• 2: Server Streaming =====
    println!("ğŸ“¤ æµ‹è¯• Server Streaming:");
    let request = tonic::Request::new(HelloRequest {
        name: "Rust Developer".into(),
    });
    let test_request = tonic::Request::new(TestRequest{
        name: "Shawn goodbye".into()
    });
    let mut stream = client.say_hello_stream(request).await?.into_inner();
    test_client.say_goodbye(test_request).await?;
    while let Some(response) = stream.message().await? {
        println!("ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: {}", response.message);
    }
    
    println!("\nğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆ!");
    
    Ok(())
}
```



1. è¿è¡Œæ•ˆæœ
server:
```rust
Got request :Request { metadata: MetadataMap { headers: {"te": "trailers", "content-type": "application/grpc", "user-agent": "tonic/0.14.2"} }, message: HelloRequest { name: "Shawn" }, extensions: Extensions }
the request is :Request { metadata: MetadataMap { headers: {"te": "trailers", "content-type": "application/grpc", "user-agent": "tonic/0.14.2"} }, message: TestRequest { name: "Shawn test" }, extensions: Extensions }
Got request :Request { metadata: MetadataMap { headers: {"te": "trailers", "content-type": "application/grpc", "user-agent": "tonic/0.14.2"} }, message: HelloRequest { name: "Rust Developer" }, extensions: Extensions }
Sending message endgoodbye, the request is :"Shawn goodbye"
```

client

```rust
ğŸ”Œ å·²è¿æ¥åˆ° gRPC æœåŠ¡å™¨

ğŸ“¤ æµ‹è¯•ä¸€å…ƒ RPC:
âœ… æ”¶åˆ°å“åº”: Hello, World, this is from the grpc server ğŸ¦€:Shawn

ğŸ“¤ æµ‹è¯• Server Streaming:
ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: this is from the grpc server message :0
ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: this is from the grpc server message :1
ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: this is from the grpc server message :2
ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: this is from the grpc server message :3
ğŸ“¨ æ”¶åˆ°æµå¼å“åº”: this is from the grpc server message :4

ğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆ!
```



1. æ€»ç»“: ç®€å•ä½¿ç”¨åœºæ™¯ä¸‹,éœ€è¦ é“¾æ¥,ç”Ÿæˆ,åœ¨é…ç½® server,æ€»ä½“çš„ä½¿ç”¨æ–¹å¼ä¸æ˜¯éå¸¸å‹å¥½,æµç¨‹ä¹Ÿç›¸å¯¹å¤æ‚. 




å¦‚æœéœ€è¦ä½¿ç”¨ç»Ÿä¸€çš„æµç¨‹ç®¡ç†, å¯ä»¥ä½¿ç”¨ proto çš„ç®¡ç†å·¥å…· buf 

åªéœ€è¦ç¼–å†™å¯¹åº”çš„buf.yaml å’Œ buf.gen.yaml å³å¯,ç„¶åå†é…ç½® CI/CD è¿›è¡Œç”Ÿæˆç®¡ç†å³å¯

è¿›è¡Œ buf init è¿›è¡Œç”Ÿæˆå¯¹åº”çš„æ–‡ä»¶

æ¯”å¦‚å¯¹åº”çš„ buf.yaml:

```yaml
version: v2
modules:
  - path: proto
lint:
  use:
    - STANDARD #ä½¿ç”¨æ ‡å‡†çš„è§„åˆ™
breaking:
  use:
    - FILE

```

buf.gen.yaml

```yaml
# buf.gen.yaml
version: v2
managed:
  enabled: true
plugins:
  # ä½¿ç”¨ buf çš„è¿œç¨‹æ’ä»¶
  - local: protoc-gen-prost  # éœ€è¦ä½¿ç”¨ cargo install protoc-gen-prost æˆ–è€…è¿™é‡ŒæŒ‡å®šè¿œç¨‹çš„å®˜æ–¹ github åœ°å€
    out: src/pb
    opt:
      - bytes=.
            # æ­£ç¡®çš„æ ¼å¼:ç”¨ç‚¹å·åˆ†éš”å¤šä¸ª derive
      - type_attribute=.=#[derive(serde::Serialize)]
      - type_attribute=.=#[derive(serde::Deserialize)]

      # æ’ä»¶ 2: tonic (ç”Ÿæˆ gRPC æœåŠ¡ä»£ç )
  - local: protoc-gen-tonic # éœ€è¦ä½¿ç”¨ cargo install protoc-gen-tonic æˆ–è€…è¿™é‡ŒæŒ‡å®šè¿œç¨‹çš„å®˜æ–¹ github åœ°å€
    out: src/pb

```

å®Œæˆä¹‹åä½¿ç”¨ buf generate å³å¯ç”Ÿæˆå¯¹åº”çš„ proto çš„ rust æ–‡ä»¶åˆ°å¯¹åº”æŒ‡å®šçš„ç›®å½•ä¸‹



å¯¹åº”çš„ç”Ÿäº§ç¯å¢ƒç¼–è¯‘,éœ€è¦åœ¨ CI/CD ç¼–å†™å¯¹åº”çš„è§„åˆ™å³å¯: 

è¿™é‡Œä»¥ github ä¸ºä¾‹, éœ€è¦åœ¨.github/workflows/ci.yml ä¸­è¿›è¡Œç”Ÿæˆ

```yaml
# .github/workflows/ci.yml
   - name: Check proto changes
     run: |
       buf generate # push æˆ–è€…PR åˆ° main åˆ†æ”¯çš„æ—¶å€™è¿›è¡Œæ‰§è¡Œ,ä»¥åŠå‘å¸ƒçš„æ—¶å€™æ‰§è¡Œç”Ÿæˆ
       git diff --exit-code  
```



